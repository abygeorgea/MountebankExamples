<%
title = 'proxies'
description = 'Using mountebank to record and playback through proxying to a real network dependency'
%>

<% include ../../_header %>

<h1>Proxies</h1>

<p>Proxies are one of the most powerful features of mountebank, rivaled only by the
mighty <a href='/docs/api/injection'>injection.</a>  Each proxied response is recorded,
either as an entirely new stub in the imposter's <code>stubs</code> array, or as a
new response in the stub's <code>responses</code> array.  Proxies allow you to define
the fields which should be included in newly created <code>predicates</code>.  The
<code>proxy</code> will ensure that the proxied request data for those fields are
filled in.</p>

<p class='info-icon'>Use the <a href='/docs/commandLine#replay'><code>mb replay</code></a> command to
    automatically remove the proxies, switching from record mode to replay mode.</p>

<p><code>proxy</code> response types take the following parameters:</p>

<table>
  <tr>
    <th>Parameter</th>
    <th style='min-width: 4em;'>Default</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td><code>to</code></td>
    <td>required</td>
    <td>A URL without the path (e.g. http://someserver:3000 or tcp://someserver:3000)</td>
    <td>Defines the origin server that the stub should proxy to.</td>
  </tr>
  <tr>
    <td><code>mode</code></td>
    <td><code>proxyOnce</code></td>
    <td>string, one of <code>proxyOnce</code> or <code>proxyAlways</code>.</td>
    <td>Defines the replay behavior of the proxy.  <code>proxyOnce</code>
    always records the proxied call in the <code>stubs</code> array in
    front of itself, so the same call is never proxied twice.  <code>proxyAlways</code>
    saves the proxied call <em>after</em> itself in the <code>stubs</code>
    array.  This allows you to capture different responses for the same call.
    You can later replay <code>proxyAlways</code> stubs by issuing a <code>GET</code>
    or <code>DELETE</code> to the imposter with the <code>removeProxies</code> and
    <code>replayable</code> query params, and re-<code>POST</code>ing the imposter.</td>
  </tr>
  <tr>
    <td><code>predicateGenerators</code></td>
    <td><code>[]</code></td>
    <td>array</td>
    <td>An array of objects that defines how the predicates for new stubs are created.</td>
  </tr>
  <tr>
    <td><code>injectHeaders</code></td>
    <td><code>{}</code></td>
    <td>object</td>
    <td>Key-value pairs of headers to inject into the proxied <i>request</i>.  This is useful when the behavior of
    the system being proxied can be altered with appropriate headers (e.g. pointing REST links back to mountebank
    for further proxying). You can also use this to pass along an 'Accept-Encoding: identity' header to prevent
    the proxy from sending back compressed data. Existing headers will be overwritten if they match the injected headers.</td>
  </tr>
  <tr>
    <td><code>addWaitBehavior</code></td>
    <td><code>false</code></td>
    <td>boolean</td>
    <td>If true, mountebank will add a <a href='/docs/api/behaviors#behavior-wait'><code>wait</code></a>
    behavior to the response with the same latency that the proxied call took. This is useful in load
    testing scenarios where you want to simulate the actual latency of downstream services that you're
    virtualizing.</td>
  </tr>
  <tr>
    <td><code>addDecorateBehavior</code></td>
    <td><code>null</code></td>
    <td>string, JavaScript</td>
    <td>If defined, mountebank will add a <a href='/docs/api/behaviors#behavior-decorate'><code>decorate</code></a>
    behavior to the response.</td>
  </tr>
</table>

<p>http and https proxies add three additional optional parameters for situations where the
origin server expects to use mutual authentication and will request a client certificate:</p>

<table>
  <tr>
    <th>Parameter</th>
    <th style='min-width: 4em;'>Default</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td><code>cert</code></td>
    <td><code>null</code></td>
    <td>A PEM-formatted string</td>
    <td>The SSL client certificate</td>
  </tr>
  <tr>
    <td><code>key</code></td>
    <td><code>null</code></td>
    <td>A PEM-formatted string</td>
    <td>The SSL client private key</td>
  </tr>
  <tr>
    <td><code>ciphers</code></td>
    <td><code>ALL</code></td>
    <td>A valid cipher (see <a href='http://openssl.cs.utah.edu/docs/apps/ciphers.html'>this page</a> for formats)</td>
    <td>For older (and insecure) https servers, this field allows you to override the cipher used to commuicate</td>
  </tr>
</table>

<p>It is occasionally useful to capture how long the original proxied request takes.  mountebank
stores the number of milliseconds for the request in the <code>_proxyResponseTime</code> field in the
response.</p>

<p class='info-icon'>Note, if you use a corporate proxy, then setting the standard shell
<code>http_proxy</code> or <code>https_proxy</code> environment variables will be honored.</p>

<h2>Understanding proxy behavior</h2>

<p>The <code>mode</code> and <code>predicateGenerators</code> parameters define the behavior of
the <code>proxy</code>.  The default <code>proxyOnce</code> mode is simpler; it always
creates a new stub.  Imagine the following <code>stubs</code> array, set by us when
we create the imposter:</p>

<pre><code>
"stubs": [
  {
    "responses": [
      {
        "proxy": {
          "to": "http://origin-server.com",
          "mode": "proxyOnce",
          "predicateGenerators": [
            {
              "matches": {
                "method": true,
                "path": true,
                "query": true
              }
            }
          ]
        }
      }
    ]
  }
]
</code></pre>

<p>When we issue a <code>GET</code> to <code>/test?q=mountebank</code>, the stub
will proxy to http://origin-server.com/test?q=mountebank, and save
off the response in a new stub in front of the <code>proxy</code> response:</p>

<pre><code>
"stubs": [
  {
    "predicates": [{
      "deepEquals': {
        "method": "GET",
        "path": "/test",
        "query": { "q": "mountebank" }
      }
    }],
    "responses": [
      { "is": ...saved response }
    ]
  }
  {
    "responses": [
      {
        "proxy": {
          "to": "http://origin-server.com",
          "mode": "proxyOnce",
          "predicateGenerators": [
            {
              "matches": {
                "method": true,
                "path": true,
                "query": true
              }
            }
          ]
        }
      }
    ]
  }
]
</code></pre>

<p>Because of mountebank's first-match policy on stubs, the next time the imposter
receives a <code>GET /test?q=mountebank</code> request, the saved predicates on the
newly created stub will match, and the recorded response will be replayed.  If
the imposter receives a <code>GET /test?q=mountebank&amp;sort=descending</code>, then
it will proxy again, creating a new stub, because the querystring is different.</p>

<p>The <code>proxyAlways</code> mode saves stubs behind the <code>proxy</code>
stub.  This allows you to record a richer set of interactions with the origin server,
but requires you to save off the imposter representation and remove or reorder the
<code>proxy</code> to replay those interactions.</p>

<p>Let's say you had the following <code>stubs</code> array:</p>

<pre><code>
"stubs": [
  {
    "responses": [
      {
        "proxy": {
          "to": "http://origin-server.com",
          "mode": "proxyAlways",
          "predicateGenerators": [
            { "matches": { "path": true } }
          ]
        }
      }
    ]
  },
  {
    "predicates": [
      { "equals": { "path": "/test" } }
    ],
    "responses": [
      { "is": { "body": "first response" } }
    ]
  }
]
</code></pre>

<p>The next time we send a request to <code>/test</code>, the request will still
be proxied to http://origin-server.com/test.  Since the predicate that we would
normally create already exists after the <code>proxy</code> stub, the proxied
response instead gets added to an existing stub's <code>responses</code> array.</p>

<pre><code>
"stubs": [
  {
    "responses": [
      {
        "proxy": {
          "to": "http://origin-server.com",
          "mode": "proxyAlways",
          "predicateGenerators": [
            { "matches": { "path": true } }
          ]
        }
      }
    ]
  },
  {
    "predicates": [
      { "deepEquals": { "path": "/test" } }
    ],
    "responses": [
      { "is": { "body": "first response" } },
      { "is": { ...saved response } }
    ]
  }
]
</code></pre>

<p><code>predicateGenerators</code> accept the same predicate parameters as
<a href='/docs/api/predicates'>predicates</a>: <code>caseSensitive</code> and
<code>except</code>.</p>

<h2>Examples</h2>

<p>Our examples will proxy to the following origin server.  To help
us keep track of the imposters in the logs, we'll set the <code>name</code>
field.  We're using <a href='/docs/api/injection'>injection</a> to return the
number of times the proxy has been called to the user.</p>

<pre><code data-test-id='proxy example'
           data-test-step='1'
           data-test-type='http'>
POST /imposters HTTP/1.1
Host: localhost:<%= port %>
Accept: application/json
Content-Type: application/json

{
  "port": 7575,
  "protocol": "http",
  "name": "origin",
  "stubs": [
    {
      "responses": [{
        "inject": "function (request, state) { state.calls = state.calls || 0; return { body: 'call ' + ++state.calls }; }"
      }]
    }
  ]
}
</code></pre>

<p>Select the behavior of the proxy below for a relevant example:</p>

<section class="accordion">
  <div>
    <input id='proxy-once' name='proxy-once' type="checkbox" />
    <label for='proxy-once'>proxyOnce</label>
    <section>
      <% include proxy/proxyOnce %>
    </section>
  </div>
  <div>
    <input id='proxy-always' name='proxy-always' type="checkbox" />
    <label for='proxy-always'>proxyAlways</label>
    <section>
      <% include proxy/proxyAlways %>
    </section>
  </div>
  <div>
    <input id='proxy-inject-headers' name='proxy-inject-headers' type="checkbox" />
    <label for='proxy-inject-headers'>injectHeaders</label>
    <section>
      <% include proxy/injectHeaders %>
    </section>
  </div>
</section>

<% include ../../_footer %>
